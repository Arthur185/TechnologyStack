### Java内存结构 / 运行时数据区域？
Java内存结构描述的是Java程序执行过程中, 由JVM管理的不同的数据区域。包括以下5部分：
==堆内存（heap）、方法区（method）、程序计数器、栈内存（stack）、本地方法栈（java中JNI调用）==

1. 堆内存（线程共享）：JVM所管理的内存中最大一块。唯一目的就是存放实例对象，几乎所有的对象实例都在这里分配。Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。异常状态 OutOfMemoryError
1. 方法区（线程共享）：方法区是被所有线程共享的区域。用于存放类的所有信息（字段、方法、构造函数等）、静态变量、常量。异常状态 OutOfMemoryError
包含运行时常量池：存放编译器生成的各种字面量和符号引用
1. 栈内存（线程私有）：一个线程对应一个栈，生命周期与线程相同。描述的是java方法执行的内存模型：每个方法执行时会创建一个栈帧，用于存放局部变量、操作数栈、方法出口等信息。每一个方法从调用直至完成的过程，对应着一个栈帧在虚拟机中入栈到出栈的过程。异常状态 OutOfMemoryError StackOverflowError
1. 本地方法栈（线程私有）：与虚拟机栈作用相似，区别在于本地方法栈用于支持Native方法执行，存储了每个Native方法调用的状态。
1. 程序计数器（线程私有）：可看做当前线程所执行的字节码的行号指示器。指向方法区方法字节码（下一个指令的地址），并由执行引擎读取并执行下一指令。

### 类的加载

类从被加载到虚拟机内存中开始，直到卸载出内存为止，它的整个生命周期包括了：==加载==、验证、准备、解析、==初始化==、使用和卸载这7个阶段。其中，验证、准备和解析这三个部分统称为==连接（linking）==。

### 类加载的具体过程
##### 加载:
1. 通过一个类的全限定名来获取定义此类的二进制字节流
1. 将这个字节流所代表的静态存储结构转换为方法区内的运行时数据结构
1. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
##### 验证：
- 是连接阶段的第一步，目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
- 包含四个阶段的校验动作
1. 文件格式验证
验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。
2. 元数据验证
对类的元数据信息进行语义校验，是否不存在不符合Java语言规范的元数据信息
1. 字节码验证
最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。
1. 符号引用验证
最后一个阶段的校验发生在虚拟机将符号引用转换为直接引用的时候，这个转换动作将在连接的第三个阶段——解析阶段中发生。
符号验证的目的是确保解析动作能正常进行。
##### 准备：

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。这些变量所使用的内存都将在方法区中分配。只包括类变量。==初始值“通常情况”下是数据类型的零值。==
“特殊情况”下，如果类字段的字段属性表中存在ConstantValue属性，那么在准备阶段变量的值就会被初始化为ConstantValue属性所指定的值。

```
例如

publicstaticintvalue = 1 ；

在准备阶段之后，value值为0，而不是1。赋值为1的动作发生在初始化阶段。

但是，也要特殊情况，如果变量被static 和 final同时修饰，则准备阶段直接赋值为指定值。如

public finallystaticintvalue = 1 ；

在准备阶段之后，value的值即为1.
```

##### 解析：

虚拟机将常量池内的符号引用替换为直接引用的过程。
“动态解析”的含义就是必须等到程序实际运行到这条指令的时候，解析动作才能进行。相对的，其余可触发解析的指令都是“静态”的，可以在刚刚完成加载阶段，还没有开始执行代码时就进行解析。
##### 初始化：

类加载过程中的最后一步。
初始化阶段是执行类构造器()方法的过程。
()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。
()与类的构造函数不同，它不需要显示地调用父类构造器，虚拟机会保证在子类的()方法执行之前，父类的()方法已经执行完毕。

简单地说，初始化就是对类变量进行赋值及执行静态代码块。

##### 例子：
```
public class Singleton {

    private static Singleton singleton = new Singleton();
    public static int counter1;
    public static int counter2 = 0;
    public Singleton() {
        counter1++;
        counter2++;
    }
    public static Singleton getSingleton() {
        return singleton;
    }

    public static void main(String[] args) {
        Singleton singleton = Singleton.getSingleton();
        System.out.println("counter1="+singleton.counter1);
        System.out.println("counter2="+singleton.counter2);
    }
}
```

##### 分析：

1、SingleTon singleTon = SingleTon.getInstance();调用了类的SingleTon调用了类的静态方法，触发类的初始化

2、类加载的时候在准备过程中为类的静态变量分配内存并初始化默认值 singleton=null count1=0,count2=0

3、类初始化化，为类的静态变量赋值和执行静态代码快。singleton赋值为new SingleTon()调用类的构造方法

4、调用类的构造方法后count=1;count2=1

5、继续为count1与count2赋值,此时count1没有赋值操作,所有count1为1,但是count2执行赋值操作就变为0

### 类加载器分类
不同的类加载器负责加载不同的类。主要分为两类。
- 启动类加载器（Bootstrap ClassLoader）： 由C++语言实现（针对HotSpot）,负责将存放在\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中，即负责加载Java的核心类。
- 其他类加载器： 由Java语言实现，继承自抽象类ClassLoader。如：
1. 扩展类加载器（Extension ClassLoader）： 负责加载\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库，即负责加载Java扩展的核心类之外的类。
1. 应用程序类加载器（Application ClassLoader）： 负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器，通过ClassLoader.getSystemClassLoader()方法直接获取。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。

### 双亲委派模型
双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。

![image](https://user-images.githubusercontent.com/22804389/171861048-b74c8fd7-4598-4583-ac3c-c53cf7af4078.png)

这样的好处是不同层次的类加载器具有不同优先级，比如所有Java对象的超级父类java.lang.Object，位于rt.jar，无论哪个类加载器加载该类，最终都是由启动类加载器进行加载，保证安全。即使用户自己编写一个java.lang.Object类并放入程序中，虽能正常编译，但不会被加载运行，保证不会出现混乱。
### 垃圾回收机制
#### 如何判断对象是否会被垃圾回收机制处理掉？
#####  引用计数法
- 原理

假设有一个对象A，任何一个对象对A的引用，那么对象A的引用计数器+1，当引用失败时，对象A的引用计数器-1，如果对象A的计数器的值为0，说明A没有引用，可以被回收。
- 特点

无法解决循环引用问题。

```
public class test {

    public static void main(String[] args) {
        
        MyObject object1=new MyObject();	// object1 引用计数 1
        MyObject object2=new MyObject();	// object2 引用计数 1
        
        object1.object=object2;				// object1 引用计数 2
        object2.object=object1;				// object2 引用计数 2
        
        object1=null;						// object1 引用计数 1 ，无法回收
        object2=null;						// object2 引用计数 1 ，无法回收
    }
}

```
##### 可达性分析算法
可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC Root开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，可达的对象都是存活的。当所有的引用节点寻找完毕之后，剩余的不可达节点则被认为是没有被引用到的节点，即无用的节点（GC Root 不可达对象），无用的节点将会被判定为是可回收的对象。
- 在Java语言中，可作为GC Roots的对象包括下面几种：
1. **虚拟机栈中引用的对象（栈帧中的本地变量表）**
1. **方法区中类静态属性引用的对象**
1. **方法区中常量引用的对象**
1. **本地方法栈中JNI（Native方法）引用的对象**

##### finalize —— 对象死亡（被回收）前的最后一次挣扎/自救计划
即使在可达性分析算法中不可达的对象，也并非是“非死不可”，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。

第一次标记：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记；
第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。即：当对象没有被覆盖finalize()或者finalize()方法已经被虚拟机调用过了，虚拟机将这两种情况都是为没有必要执行。

第二次标记：当一个对象被判断为有必要执行finalize()方法，那么这个对象会被放置到F-Queue队列中，并且稍后JVM自动建立一个低优先级的Finalizer线程执行它，这里“执行”是虚拟机会触发这个方法，但不会承诺等待它运行结束（万一这个方法运行缓慢或者死循环，F-Queue队列其他对象岂不是永久等待）。finalize()是对象逃脱死亡的最后一次机会。稍后GC会对F-Queue进行第二次小规模标记。如果对象能在finalize()方法中重新与引用链上任何一个方法建立关联（例如把自己this关键字赋值给某个类变量或者对象的成员变量）。那么第二次标记时，将会移出即将回收的集合。否则，这个对象就会被回收了。
### java种的4种引用以及用法
##### 强引用
被强引用关联的对象不会被垃圾回收器回收。使用 new 一个新对象的方式来创建强引用。

```
Object obj = new Object();
```

##### 软引用
用来描述一些还有用但并非必须的对象。被软引用关联的对象只有在内存不够的情况下才会被回收。使用 SoftReference 类来创建软引用。

```
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;  // 使对象只被软引用关联
```

##### 弱引用
用来描述无用对象的，被弱引用关联的对象只要被垃圾回收器扫描到，无论内存是否足够，就一定会回收，即被弱引用关联的对象只能生存到下一次垃圾收集发生之前。使用 WeakReference 类来创建弱引用。

```
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
```

##### 虚引用
也叫幽灵引用或幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。它的唯一作用是能在这个对象被收集器回收时收到一个系统通知。使用 PhantomReference 来创建虚引用。

```
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
obj = null;
```
### GC回收算法有哪些？优缺点？
##### 标记清除法
###### 原理
标记清除算法，是将垃圾回收分为2个阶段，分别是标记和清除。
- 标记：从根节点开始标记引用的对象。
- 清除：未被标记引用的对象是垃圾对象，可以被清理。
###### 特点
标记清除算法解决了循环引用问题（没有从root节点引用的对象都会被回收）

但通过清除算法清理出来的内存，碎片化较为严重。因为被回收的对象可能存在于内存的各个角落，所以清理后的空闲内存不连贯。
##### 标记压缩法
###### 原理
标记压缩算法是标记清除算法的基础上，做了优化改进的算法。和标记清除算法一样，也是从根节点开始，对对象的引用进行标记，在清理阶段，并不是简单的清理未标记对象，而是将存活的对象压缩到内存的一段，然后清理边界以外的垃圾，从而解决了碎片化的问题。
###### 特点
解决了标记清除算法的碎片化问题。
但是标记压缩算法多了一步，对象移动内存位置的步骤，其效率有一定影响。
##### 复制算法
###### 原理
复制算法的核心就是，将原有的内存空间一分为二，每次只用其中的一块，在垃圾回收时，将正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收。

如果内存中的垃圾对象较多，需要复制的对象就较少，这种情况下适合使用该方法并且效率较高，反之，则不适合。
###### 特点
适用于垃圾对象较多的情况，且清理后，内存无碎片。但不适用于垃圾对象少的情况（如老年代内存），且分配的2块内存空间，在同一个时刻，只能使用一半，内存使用率较低。
##### 分代算法
分代算法根据回收对象的特点进行选择，在jvm中，**年轻代适合使用复制算法，老年代适合使用标记清除/压缩算法**。
